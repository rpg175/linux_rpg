# boot 整体技术策略

1. 加载bootsect 到0x7C00，然后复制0x90000
2. 加载setup到0x90200
3. head执行：
   1. 将head.s汇编成目标代码 head.o
   2. 将用C语言编写的内核程序编译成目标代码 main.o
   3. 然后将 head.o+main.o 链接成system模块。也就是system模块里面既有head程序，也有内核程序。
   4. head.o占有25kb+184b的空间
4. setup将system模块复制到0x00000位置，由于head程序在system前面，所以实际上，head程序就在0x00000
5. head程序除了做一些调用main的准备工作之外，还做了一件对内核程序在内存中的布局及内核程序的正常运行有重大意义的事：
   1. 用程序自身的代码在程序自身所在的内存空间创建了内核分页机制，
   2. 在0x000000的位置创建了页目录表、页表、缓冲区、GDT、IDT，
   3. 并将head程序已经执行过的代码所占内存空间覆盖。
6. 意味着head程序自己将自己废弃，main函数即将开始执行。

## cpu什么时候变成保护模式执行
*.通电的时候，应该CPU执行指令的时候应该是实模式，然后BIOS加载操作系统代码的时候，还是实模式，CPU开始执行操作系统代码...翻看了一下linux0.11的代码，发现在setup.s看到了 jmpi 0，8......
*.head.s是直接操作物理内存，但是jmpi 0，8把cs和GDT关联，然后bios把head.s移动内存0x00000000处，这时候线性内存地址=物理内存地址......

## 操作系统的先机
* 操作系统先于其他应用进入保护模式并获得了R0权限
* 如果有病毒先于操作系统获得R0权限，这时候病毒就脱离了操作系统的管理
