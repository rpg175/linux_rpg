# linux0.11的文件系统

操作系统对文件的一切操作，都可以分为两个方面：对super_block、d_super_block、m_inode、d_inode、i节点位图、逻辑块位图这类文件管理信息的操作以及对文件数据内容的操作。新建、打开、关闭、删除文件属于对文件管理信息的操作。读文件、写文件和修改文件则主要是操作文件数据内容。
操作文件管理信息就是建立或解除进程与文件的关系链条，链条的主干为task_struct中的*filp[20]——file_table[64]——inode_table[32]。进程就可以沿着关系链条，依托缓冲区与硬盘进行数据交互。当关系链条解除后，进程则不再具备操作指定文件的能力。如果文件管理信息被更改，则操作系统要将此更改落实在硬盘上，以免失去对文件数据内容的控制

## 数据同步到外设的两种方法
数据从缓冲区同步到硬盘有两种方法。
* 通过updata定期同步；
* 因缓冲区使用达到极限，操作系统强行同步。

### 第一种方法：通过updata定期同步
shell进程在第一次执行时，启动了一个updata进程。
这个进程常驻于内存，功能就是将缓冲区中的数据同步到外设上。
该进程会调用pause（）函数，这个函数会映射到sys_pause（）函数中，使该进程被设置为可中断等待状态。
每隔一段时间，操作系统就将updata进程唤醒。
它执行后，调用sync（）函数，将缓冲区中的数据同步到外设上。
sync（）函数最终映射到sys_sync（）系统调用函数去执行。
为了保证文件内容同步的完整性，需要将文件i节点位图、文件i节点、文件数据块、数据块对应的逻辑块位图，全都同步到外设。
sys_sync（）函数先将改动过的文件i节点写入缓冲区（其余内容已经在缓冲区中了），之后，遍历整个缓冲区，
只要发现其中缓冲块内容被改动过（b_dirt被置1），就全部同步到外设上。

### 第二种方法：写入数据超过缓冲区，比如超过10mb
要写入的数据将达到10 MB以上，而缓冲区，肯定不可能超过10 MB。
因此，当前进程要写入数据的话，很可能在updata进程被唤醒之前，就已经将缓冲区写满。
若继续写入，就需要强行将缓冲区中的数据同步到硬盘，为续写腾出空间。
此任务是由getblk（）函数完成的。
当在缓冲区中找到的空闲块都已经无法继续写入信息（b_dirt都是1）时，就说明需要腾空间了

```
struct buffer_head * getblk(int dev,int block) {
    ....
    while（bh-＞b_dirt）{
        //虽然找到空闲缓冲块，但b_dirt仍是1，说明缓冲区中已无可用的缓冲块了，需要同步腾空　　
        sync _dev（bh-＞b_dev);
        //同步数据　　
        wait _on_buffer（bh;
    　　if（bh-＞b_count）　　
           goto repeat；　　
    }
    ....
}
```

## 修改文件
修改文件的本质就是可以在文件的任意位置插入数据、删除数据，且不影响文件已有数据。
此问题的处理方案是：将sys_read（）、sys_write（）以及sys_lseek（）几个函数组合使用。
sys_read（）和sys_write（）

```c
#include<fcntl.h>
#include<stdio.h>
#include<string.h>
#define LOCATION 6

int main(char argc,char ** argv)
{
    char str1[]="Linux";
    char str2[1024];
    int fd,size;
    memset(str2,0,sizeof(str2));
    fd=open("hello.txt",O_RDWR,0644);
    lseek(fd,LOCATION,SEEK_SET);
    strcpy(str2,str1);
    size=read(fd,str2+5,6);
    lseek(fd,LOCATION,SEEK_SET);
    size=write(fd,str2,strlen(str2));
    close(fd);
    return 0:
}
```

## 关闭文件
1. 当前进程的file与file_table[64]脱勾。
   1. 通过fd找到file_table中的file，
   2. 将file_table[fd]重置为null，
   3. 将file->f_count 引用计数器减1，
   4. iput(file->f_inode)脱勾
2. 文件inode被释放：先要对inode进行检查，然后将inode的i_count减1，当inode的引用计数变为0，这个inode_table[32]中的表项为空闲项。

## 删除文件
1. 删除的文件，需要保证其他进程都无法访问
2. 删除文件，需要将逻辑块位图清空，inode节点位图清空，目录项清空

## 页写保护
1. 进程A和一个进程B共享页面
   1. 系统有一个进程A，对应的程序代码已经加载到内存中，进程内存中所占用的页面引用计数都为"1"
   2. 进程A，通过fork函数创建了一个新进程B。在创建B过程中系统将A的页表项全部复制给B，并设置B的目录项。
   3. 此时A，B就共享页面，被共享页面的引用计数累积为2，并被系统设置为只读属性
2. 进程A准备进行压栈操作
   1. 由于进程A对应所以页面都是只读状态。压栈是写操作。硬件cpu不允许
   2. 压栈时，压栈时对应的线性地址值经过解析后肯定会映射到只读页面中，就会产生一个“页写保护”中断。
3. 进程A的压栈动作引发页面写保护
   1. “页写保护”中断对应的服务程序是un_wp_page（）函数，
   2. 函数执行时，先要在主内存中申请一个空闲页面（以后我们称之为新页面），
   3. 以便备份刚才压栈的位置所在页面（以后我们称之为原页面）的全部数据，
   4. 然后将原页面的引用计数减1。
4. 将进程A的页表指向新申请的页面 
   1. 新页面虽然申请到了，但此时进程A的页表中与原页面对应的页表项还是指向原页面，
   2. 没有页表项与页面对应，最终还是无法找到物理地址的。
   3. 所以，现在还需要让进程A的页表中指向原页面的页表项改为指向新页面，
   4. 并将其使用的属性从“只读”改变为“可读可写”，这样进程A才具备了在新页面中处理数据的能力。
5. 复制原页面内容到进程A新申请的页面
   1. 一切准备就绪后，就可以将原页面中的内容复制到新页面中了。
   2. 复制之后，进程A就可以在新页面中完成这个压栈动作了。
6. 进程B准备操作共享页面
   1. 进程A执行一段时间后，就该轮到它的子进程——进程B执行了。
   2. 进程B仍然使用着原页面。假设也要在原页面中进行写操作，
   3. 但是现在原页面的属性仍然是“只读”的，这一点在进程A创建进程B时就是这样设置的，
   4. 一直都没有改变过。所以在这种情况下，又需要进行页写保护处理，
   5. 仍然是映射到un_wp_page（）函数中。由于原页面的引用计数已经被削减为1了，
   6. 所以现在就要将原页面的属性设置为“可读可写”
7. 假设进程B先执行压栈操作的情况 
   1. 我们重新假设，现在不是父进程——进程A先执行，而是子进程——进程B先执行，那么又会出现什么情况呢